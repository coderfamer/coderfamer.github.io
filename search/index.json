[{"content":"准备 ","date":"2022-12-12T11:11:30+08:00","permalink":"https://coderfamer.github.io/p/cmake-%E4%BD%BF%E7%94%A8-sphinx-%E6%9E%84%E5%BB%BA%E6%96%87%E6%A1%A3%E7%B3%BB%E7%BB%9F/","title":"cmake 使用 sphinx 构建文档系统"},{"content":" sphinx 文档构建系统\n简介 安装 为了防止环境混乱，建议使用 conda 创建新环境安装\n依赖 conda 安装 conda 并创建新环境 安装 conda 创建新虚拟环境 1 2 conda env create -n sphinx --no-default-packages --file=req.txt conda activate sphinx cat req.txt\n1 2 python=3.8 pip conda 会创建一个只包含 python 和 pip 名为 sphinx 的环境\n安装 sphinx 以及 依赖 安装 sphinx\n1 pip install sphinx 若需要支持 markdown 和表格，安装\n1 2 pip install recommonmark pip install sphinx-markdown-tables 若需要生成 pdf\n1 pip install rst2pdf 使用教程 使用 sphinx-quickstart 创建空白项目\n1 sphinx-quickstart 配置相关属性，构建\n1 make html build/html 目录会生成静态网页\nsphinx-quickstart sphinx-build\n引用 sphinx-practise.readthedocs.io\n","date":"2022-12-07T17:50:55+08:00","permalink":"https://coderfamer.github.io/p/sphinx-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","title":"Sphinx 安装使用"},{"content":"hugo 安装和使用 hugo 安装 建立站点 1 hugo new site hugo_blog 添加主题 1 2 3 cd hugo_blog git init git submodule add https://github.com/budparr/gohugo-theme-ananke.git themes/ananke 配置文件中使用指定主题\n1 echo \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt;config.toml 创建新文章 1 hugo new posts/my-first-post.md 1 2 3 4 5 6 7 --- title: \u0026#34;My First Post\u0026#34; date: 2022-12-02T00:00:08+08:00 draft: false --- ## first post 开启本地服务 1 hugo server --bind=0.0.0.0 --baseURL=http://\u0026lt;yourhost\u0026gt;:1313 在 github 部署个人博客 使用 github 的 user pagers 功能创建\ncoderfamer.github.io\n1 2 rm -rf public git submodule add -b master git@github.com:\u0026lt;yourgitname\u0026gt;/\u0026lt;yourgitname\u0026gt;.github.io.git public 在根目录的 config.toml 添加 baseURL\n1 baseURL = \u0026#39;https://\u0026lt;youergit\u0026gt;.github.io/\u0026#39; 生成静态网页，提交代码\n1 2 3 4 5 hugo cd public git add --all git commit . \u0026#34;first post\u0026#34; git push origin master ","date":"2022-12-02T00:20:59+08:00","permalink":"https://coderfamer.github.io/p/hugo/","title":"Hugo"},{"content":"合并多个 svn 存储库到一个 git 存储库中 简介 合并多个 svn 项目到一个存储库\n步骤 在 git 上面创建新的git 仓库\n1 2 3 4 5 6 7 # 首先在 git 上创建一个新的仓库 mkdir git_project \u0026amp;\u0026amp; cd git_project git init git remote add origin git@192.168.20.98:dpi_tools/ya_env.git # 设置 git 仓库 git add README.md git commit -m \u0026#34;add README\u0026#34; git push -u origin master # 提交 READERME 使用 git svn 检出 svn 项目\n1 2 git svn clone http://svn_server/svn/proj_a proj_a git svn clone http://svn_server/svn/proj_b proj_b git 目录添加检出的 svn 项目\n1 2 3 4 5 cd git_project git remote add proj_a ../proj_a git remote add proe_b ../proj_b git pull proj_a git pull proj_b 合并检出的项目\n1 2 3 4 5 git branch -avv # 查看新增的所有分支 git checkout master git merge remote/proj_a/master git merge remote/proj_b/master git push origin master ","date":"2022-09-23T15:07:32Z","permalink":"https://coderfamer.github.io/p/%E5%90%88%E5%B9%B6%E5%A4%9A%E4%B8%AA-svn-%E5%AD%98%E5%82%A8%E5%BA%93%E5%88%B0%E4%B8%80%E4%B8%AA-git-%E5%AD%98%E5%82%A8%E5%BA%93%E4%B8%AD/","title":"合并多个 svn 存储库到一个 git 存储库中"},{"content":"vscode remote 离线安装 内网环境下，想要使用 vscode 并远程到 linux 开发机器，需要手动下载\n安装 系统要求 git 或者 ssh 客户端 windows 安装 vscode 安装 vscode 自行下载安装 vscode\n安装完毕之后，打开 vscode help-\u0026gt;about 查看版本信息，记录 commit\n安装 remote 插件 插件下载地址 Extensions for Visual Studio family of products | Visual Studio Marketplace\nms-vscode-remote.remote-containers-0.238.1.visx ms-vscode-remote.remote-ssh-0.81.2022060215.vsix ms-vscode-remote.remote-ssh-edit-0.80.0.vsix ms-vscode-remote.remote-wsl-0.66.3.vsix ms-vscode-remote.vscode-remote-extensionpack-0.21.0.vsix 侧边栏 Extensions图标-\u0026gt;侧边栏三个点(···)-\u0026gt;Install from VSIX 本地离线安装插件\nlinux 安装 vscode windows 和 linux 对应的 commit 是一样的，根据 commit 下载，例如 1.67.2 的 commit 是 c3511e6c69bb39013c4a4b7b9566ec1ca73fc4d5\n下载\n1 2 3 4 wget https://update.code.visualstudio.com/commit:c3511e6c69bb39013c4a4b7b9566ec1ca73fc4d5/server-linux-x64/stable tar -zxvf stable # 解压后目录名为 vscode-server-linux-64 mkdir -p ${HOME}/.vscode-server/bin \u0026amp;\u0026amp; cd ${HOME}/.vscode-server/bin mv vscode-server-linux-64 ${HOME}/.vscode-server/bin/c3511e6c69bb39013c4a4b7b9566ec1ca73fc4d5 拷贝 ssh 密钥到远程服务器，就可以远程连接了.其他插件自行安装\n","date":"2022-06-06T15:07:32Z","permalink":"https://coderfamer.github.io/p/vscode-remote-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/","title":"vscode remote 离线安装"},{"content":"centos7 clash 科学上网 做开发经常需要访问国外编程网站，下载资料、访问 git 的时候经常会断连，需要部署网络代理，在 windows 上部署非常简单，只要下载 clash 客户端，导入 服务商的代理配置文件即可。在 linux 系统上就需要一些特殊步骤了\n前提 软件\nclash\ndocker\n文件和配置 clash 服务商 yaml 配置 Country.mmdb（启动 clash 会自动下，建议手动下载）\n安装 clash 客户端 下载 clash\n1 2 3 mkdir /opt/clash \u0026amp;\u0026amp; cd /opt/clash wget https://github.com/Dreamacro/clash/releases/download/v1.10.6/clash-linux-amd64-v1.10.6.gz --no-check-certificate gunzip -c clash-linux-amd64-v1.10.6.gz \u0026gt; clash \u0026amp;\u0026amp; chmod +x clash 下载 Country.mmdb\n1 2 mkdir -p ${HOME}/.config/clash \u0026amp;\u0026amp; cd ${HOME}/.config/clash wget https://dl.ssrss.club/Country.mmdb --no-check-certificate 导入服务商配置文件\n1 2 cd ${HOME}/.config/clash wget -O config.yaml \u0026#34;class订阅链接\u0026#34; 配置代理端口\n系统用户配置 1 2 3 echo export http_proxy=http://127.0.0.1:7890 \u0026gt;\u0026gt; /etc/profile echo export https_proxy=http://127.0.0.1:7891 \u0026gt;\u0026gt; /etc/profile source /etc/profile 当前用户配置 1 2 3 echo export http_proxy=http://127.0.0.1:7890 \u0026gt;\u0026gt; ${HOME}/.bashrc echo export https_proxy=http://127.0.0.1:7891 \u0026gt;\u0026gt; ${HOME}/.bashrc source ${HOME}/.bashrc config.yaml 主要配置项修改 ${HOME}/.config/clash\n1 2 3 4 # ip 设置为 127.0.0.1 只能本机访问，如若想局域网访问，设置地址为 0.0.0.0 external-controller: 127.0.0.1:9090 # 端口可自行修改 # RESTful api 口令，后续 web 访问使用，自行设置 secret: \u0026#34;11111\u0026#34; web 页面配置 有两种方法可以配置 web 页面，分别是 [clash Dashboard](Clash (razord.top)) 和 docker clash Dashbaord\nclash Dashboard 访问 直接访问 http://clash.razord.top/#/proxies ，输入 ip、端口和口令，即可进行切换节点、延迟测试等操作\ndocker clash DashBoard 确保 docker 已经安装完毕\n1 2 docker pull haishanh/yacd docker run -p 1234:80 -d haishanh/yacd # 端口映射到 80，随意配置未用端口 浏览器输入主机ip+端口即可访问 :1234\n引用 clash核心程序 docker 环境运行，支持 restful接口，dashboard ui，一端运行支持所有的操作系统，Linux|windows|macos|ios|安卓|科学上网 (cfmem.com)\nLinux(Centos7) 使用Clash For Linux网络代理工具教程 – 记忆角落 (199604.com)\nReleases · Dreamacro/clash (github.com)\nDocker+Clash 部署透明“网关”的实现 - 知乎 (zhihu.com)\n","date":"2022-06-03T15:07:32Z","permalink":"https://coderfamer.github.io/p/centos7-clash-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/","title":"centos7 clash 科学上网"},{"content":"centos 7 离线安装 kubernets (k8s) 下载离线安装包 准备一个可以连接外网的 centos7 机器，机器做好快照。\n准备 安装必要程序\n1 yum install yum-utils 生成docker 安装包 因需要 docker 程序拉取 k8s 的相关镜像，测试机需要安装 docker\n更新 docker 源 1 2 yum install -y epel-release.noarch yum-config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo 导出并安装 导出 docker 安装包和其依赖包\n1 2 mkdir docker \u0026amp;\u0026amp; cd docker yumdownloader --resolve docker ce 安装并启动 docker\n1 2 yum install -y docker-ce systemctl start docker 1 systemctl enable docker \u0026amp;\u0026amp; systemctl start docker k8s 包及相关镜像 k8s 安装包 导出 配置修改 yum 源 vim /etc/yum.repos.d/kubernets.repo\n1 2 3 4 5 6 7 8 [kubernetes] name=Kubernetes baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=1 repo_gpgcheck=0 gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg 重新生成 repo 信息\n1 yum clean all \u0026amp;\u0026amp; yum makecache 离线下载安装包\n1 yumdownlaoder --reslove kubelet kubeadm kubectl 查看安装包 ls k8s 相关镜像导出 k8s 基本镜像如下\n1 2 3 4 5 6 7 k8s.gcr.io/kube-apiserver:v1.23.6 k8s.gcr.io/kube-controller-manager:v1.23.6 k8s.gcr.io/kube-scheduler:v1.23.6 k8s.gcr.io/kube-proxy:v1.23.6 k8s.gcr.io/pause:3.6 k8s.gcr.io/etcd:3.5.1-0 k8s.gcr.io/coredns/coredns:v1.8.6 docker 拉取所有镜像，并导出镜像\n1 2 3 4 # 拉取镜像、打标签、删除旧的镜像 docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.23.6 docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.23.6 k8s.gcr.io/kube-apiserver:v1.23.6 docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/kube-apiserver:v1.23.6 1 2 # 导出镜像保存为 tar 包 docker save -o kube-apiserver.tar k8s.gcr.io/kube-apiserver:v1.23.6 对所有的镜像执行类似操作，可以通过脚本解决 将所有导出的 rpm 包和 tar 镜像打包保存备用。\n下载网络插件 选择一 选用 Flannel 插件\nflannel\n下载 flanneld-v0.17.0-amd64.docker 文件备用\n选择二 选用 calico 网络插件\ncalico\n下载网络插件\n1 2 wget https://docs.projectcalico.org/v3.20/manifests/calico.yaml kubectl apply -f calico.yaml docker 会自动下载 calico 相关镜像 导出，备用\n准备好的包大概如下 安装 k8s 准备操作 1 2 3 4 5 6 7 8 9 # 关闭防火墙 systemctl disalbe firewalld systemctl stop firewalld # 关闭 selinux sed -i \u0026#39;s/SELINUX=enforcing/SELINUX=disabled/g\u0026#39; /etc/sysconfig/selinux setenforce 0 # 禁用 swap 分区 swapoff -a # 临时禁用 sed -i \u0026#39;s/.*swap.*/#\u0026amp;/\u0026#39; /etc/fstab #永久禁用 设置 iptables 网桥参数\n1 2 3 4 cat \u0026lt;\u0026lt;EOF | tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF 1 2 sysctl --system sysctl -a 安装 docker 拷贝保存好的 docker 相关 rpm 包\n1 2 cd docker yum localinstall -y docker-ce 修改 docker 的 cgroup 驱动\n1 2 3 4 5 6 7 8 9 10 cat \u0026lt;\u0026lt;EOF \u0026gt; /etc/docker/daemon.json { \u0026#34;exec-opts\u0026#34;: [\u0026#34;native.cgroupdriver=systemd\u0026#34;], \u0026#34;log-driver\u0026#34;: \u0026#34;json-file\u0026#34;, \u0026#34;log-opts\u0026#34;: { \u0026#34;max-size\u0026#34;: \u0026#34;100m\u0026#34; }, \u0026#34;storage-driver\u0026#34;: \u0026#34;overlay2\u0026#34; } EOF 启动docker\n1 2 3 systemctl daemon-reload systemctl start docker systemctl enable docker 安装 k8s 拷贝 k8s 相关 rpm 包\n1 2 3 4 cd k8s yum localinstall * --disableexcludes=kubernetes systemctl start kubelet systemctl enable kubelet 加载 k8s 相关镜像 拷贝相关镜像包\n1 2 cd images find -type f -iname \u0026#34;*.tar\u0026#34; | xargs -i docker load --input {} 加载 k8s 网络插件相关镜像\n1 2 cd calico find -type f -iname \u0026#34;*.tar\u0026#34; | xargs -i docker load --input {} 安装 master 节点 以及 node 加入集群 master 节点 所有的准备工作已经就绪，运行 kuberadm init 命令即可意见安装 k8s 的 master 节点, kubeadm 安装过程不会初始化网络插件，安装网络插件对 kuberadm init 会有一定的参数要求。以 calico 为例，安装时候需要指定 \u0026ndash;pod-network-cidr=192.168.0.0/16\n安装 默认 hostname 可能为 localhost.localdomain，可以通过 hosntame 命令查看，需要修改 hostname 名称，防止后续添加 node 冲突\n1 2 # 设置 hostname hostnamectl set-hostname k8s-master 安装 master 节点\n1 kubeadm init --pod-network-cidr=192.168.0.0/16 安装成功之后，需要配置admin.conf,安装成功结尾处也会提示如何配置，同时需要保存输出最后一行的 join 命令 有两种方法可以配置 admin.config\n非 root 用户\n1 2 3 4 # 复制配置文件 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config root 用户\n1 2 # 设置环境变量 export KUBECONFIG=/etc/kubernetes/admin.conf 保存生成的 join 命令\n1 2 kubeadm join 192.168.0.20:6443 --token 96f70b.i1asdsfderoaiq5o \\ --discovery-token-ca-cert-hash sha256:c2ada929e36dd048298adb438fdafdsab8f2a6e499911fa09fce26 配置网络插件 到当前步骤， k8s 基本安装完成，但是节点依然是 NotReady 状态，这是因为还没有安装网络插件。 拷贝事先准备好的的 calico.yml\n1 kubectl apply -f calico.yml 安装配置完成之后，等待片刻，再次查看节点状态。kubectl get nodes，可以看到状态已经变为 Ready 状态 node 节点加入集群 node 节点安装配置除去 kuberadm init 和 网络插件配置之外，安装步骤基本一致（node 节点上也不用安装 kubectl）。\n更改 hostname 1 hostnamectl set-hostname node1 加入集群 使用 kubeadm join 加入集群，拷贝之前步骤中安装成功之后生成的 join 命令\n1 2 kubeadm join 192.168.0.20:6443 --token 96f70b.i1asdsfderoaiq5o \\ --discovery-token-ca-cert-hash sha256:c2ada929e36dd048298adb438fdafdsab8f2a6e499911fa09fce26 hostname\nselinux\nfirewalld\nswapoff -a\n下载 Kubernets 的相关镜像 查看所需镜像列表\n1 kubeadm config image list kubeadm init \u0026ndash;pod-network-cidr=192.168.0.0/16\n","date":"2022-04-23T15:07:32Z","permalink":"https://coderfamer.github.io/p/centos7-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85-kubernets-k8s/","title":"centos7 离线安装 kubernets (k8s)"},{"content":"k8s 重新生成 token k8s 安装之后会自动生成一个有效期为 24h 的 token，超时之后就需要重新生成新的 token\n方法 生成 token\n1 kubeadm token create 获取ca证书 hash 值\n1 openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2\u0026gt;/dev/null | openssl dgst -sha256 -hex | sed \u0026#39;s/^.* //\u0026#39; ** 查看 token **\n1 kubeadm token list 上述步骤完成之后就可以添加新的 node 节点到 master 了\n1 kubeadm join \u0026lt;master_ip\u0026gt;:6443 --token \u0026lt;TOKEN\u0026gt; --discovery-token-ca-cert-hash share256:\u0026lt;HASH\u0026gt; ","date":"2022-04-23T15:07:32Z","permalink":"https://coderfamer.github.io/p/k8s-%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90-token/","title":"k8s 重新生成 token"},{"content":"windows 清除 samba 登录状态 简介 windows 登录 samba 共享目录之后，会保存当前用户的缓存，每次访问之后就无需再次输入账户密码，想要使用其他账户就需要把当前账户状态清理掉\n操作 方法一 重启电脑，如果保存用户名密码重启电脑不会清理账户状态\n方法二 命令行清理\n打开 cmd 命令行窗口\n查看所有连接\n1 net use 清除某个连接\n1 net use \u0026lt;remote-name\u0026gt; /del 清除所有连接\n1 net use * /del ","date":"2022-03-14T15:07:32Z","permalink":"https://coderfamer.github.io/p/windows-%E6%B8%85%E9%99%A4-samba-%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81/","title":"windows 清除 samba 登录状态"},{"content":"git 基于某个分支重建项目 简介 项目中因为不同需求构建多分支，其中某个分支改动量较大，想要独立成一个业务项目，本文记录了相关操作\n过程 重建 在项目目录中检出分支\n1 git checkout \u0026lt;branch_name\u0026gt; 拷贝项目到一个新的目录，并切换目录\n1 cp project new_project -r \u0026amp;\u0026amp; cd new_project 替换当前分支为主分支\n1 2 git branch -D master git branch -m master 建立远程仓库（根据项目仓库所在位置，自行创建）\n修改仓库地址并提交内容\n1 2 git remote set-url origin \u0026lt;new-remote-url\u0026gt; git push origin master 清理分支 如果旧项目中有很多分支和远程分支，在新项目中会显的杂乱，可以利用 git 命令清理一些无效分支，即不想保存在 remote 的分支\n查看无效分支\n1 git remote prune origin --dry-run 清理无效分支\n1 git remote prune origin 如果本地还有一些已检出的分支需要清理，需要手动在本地清理\n1 git branch -d \u0026lt;branch1 branch2 ...\u0026gt; ","date":"2022-03-08T15:07:32Z","permalink":"https://coderfamer.github.io/p/git-%E5%9F%BA%E4%BA%8E%E6%9F%90%E4%B8%AA%E5%88%86%E6%94%AF%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/","title":"git 基于某个分支重新构建项目"},{"content":"cmake external 外部项目超级构建设置 runtime 路径 简介 在使用 cmake 超级构建的时候，想要指定二进制文件的输出路径。\nExternalProject_Add 参数中有一个 BINARY_DIR 选项可以指定输出路径，在构建的过程中，发现这个参数输出路径不仅会包含编译的二进制文件，还会把 cmake 自身产生的一些二进制文件同时包含进去。\n后参阅 cmake 文档，发现 ExternalProject_Add 中的 CMAKE_ARGS 选项和 set_target_properties 搭配可仅仅指定编译的二进制文件输出到指定路径\n配置 目录结构 代码 顶层 CMakeLists.txt 内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cmake_minimum_required(VERSION 3.5) project(demo LANGUAGES CXX) set_property(DIRECTORY PROPERTY EP_BASE ${CMAKE_BINARY_DIR}/subprojects) set(STAGED_INSTALL_PREFIX ${CMAKE_BINARY_DIR}/stage) include(ExternalProject) ExternalProject_Add( log SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/src CMAKE_ARGS -DRUNTIME_OUTPUT_DIRECTORY=${PROJECT_SOURCE_DIR}/run BUILD_ALWAYS 1 INSTALL_COMMAND \u0026#34;\u0026#34; ) CMAKE_ARGS 添加 runtime 参数 src 目录中 CMakeLists.txt 内容\n1 2 3 4 5 6 7 8 9 10 11 cmake_minimum_required(VERSION 3.5) project(demo_core LANGUAGES CXX) add_executable(core main.cpp) message(\u0026#34;=========================${RUNTIME_OUTPUT_DIRECTORY}\u0026#34;) set_target_properties(core PROPERTIES RUNTIME_OUTPUT_DIRECTORY \u0026#34;${RUNTIME_OUTPUT_DIRECTORY}\u0026#34; ) main.cpp\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; int main() { std::cout \u0026lt;\u0026lt; \u0026#34;hello!!!\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 构建\n1 2 3 mkdir build \u0026amp;\u0026amp; cd build cmake .. make 产出目录结构和运行 引用 ExternalProject — CMake 3.23.0-rc2 Documentation\ncmake-buildsystem(7) — CMake 3.23.0-rc2 Documentation\nCMake set CMAKE_RUNTIME_OUTPUT_DIRECTORY for a specific target only - Stack Overflow\n","date":"2022-03-06T23:07:32Z","permalink":"https://coderfamer.github.io/p/cmake-external-%E5%A4%96%E9%83%A8%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE-runtime-%E8%B7%AF%E5%BE%84/","title":"cmake external 外部项目设置 runtime 路径"},{"content":"utf-8 编码 简介 UTF-8 （8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，也是一种前缀码。它可以用一至四个字节对Unicode字符集中的所有有效编码点进行编码，属于Unicode标准的一部分，最初由肯·汤普逊和罗布·派克提出。\n编码方式 range Byte1 Byte2 Byte3 Byte4 0000-007F 0xxxxxxx 0080-07FF 110xxxxx 10xxxxxx 0800-FFFF 1110xxxx 10xxxxxx 10xxxxxx 10000-10FFFFls 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 对于UTF-8字符：\n0xxxxxxx：单字节表示一个字符\n110xxxxx： 双字节表示一个字符\n1110xxxxx： 三字节表示一个字符\n11110xxx： 四字节表示一个字符\n判定标准 假设字符串为p(c语言)\n1 2 3 4 5 6 // 双字节 (p[0] \u0026amp; 0xE0) == 0xC0 \u0026amp;\u0026amp; (p[1] \u0026amp; 0xC0) == 0x80 // 三字节 (p[0] \u0026amp; 0xF0) == 0xE0 \u0026amp;\u0026amp; (p[1] \u0026amp; 0xC0) == 0x80 \u0026amp;\u0026amp; (p[2] \u0026amp; 0xC0) == 0x80 // 四字节 (p[0] \u0026amp; 0xF8) == 0xF0 \u0026amp;\u0026amp; (p[1] \u0026amp; 0xC0) == 0x80 \u0026amp;\u0026amp; (p[2] \u0026amp; 0xC0) == 0x80 \u0026amp;\u0026amp; (p[3] \u0026amp; 0xC0) == 0x80 引用 UTF-8 strings in C (1/3) - DEV Community\nUTF-8 - 维基百科，自由的百科全书 (wikipedia.org)\n","date":"2022-03-01T15:07:32Z","permalink":"https://coderfamer.github.io/p/utf-8-%E7%BC%96%E7%A0%81/","title":"utf-8 编码"},{"content":" 简介 SR-IOV（Single Root I/O Virtualization） 是由 PIC-SIG 组织定义的 PCIe 规范的扩展规范，目的是通过一种标准规范，为虚拟机提供独立的内存空间、终端、DMA数据流。\n配置过程 bios 设置 配置 VT-d 和 SR-IOV 开关\n开启iommu 修改 grub 文件\n1 vim /etc/default/grub 在 GRUB_CMDLINE_LINUX 行尾，追加上 inter_iommu=on iommu=pt\n1 GRUB_CMDLINE_LINUX=\u0026#34;crashkernel=auto rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet intel_iommu=on iommu=pt\u0026#34; 重新生成启动配置\n1 grub2-mkconfig -o /boot/grub2/grub.cfg 启动时生成虚拟网卡 vim /etc/rc.local，在文件尾部添加如下内容\n1 echo 2 \u0026gt; /sys/class/net/\u0026lt;ethname\u0026gt;/device/sriov_numvfs # 2: 要生成的虚拟网卡个数 \u0026lt;ethname\u0026gt;:生成虚拟网卡的物理网卡名 虚拟网卡添加固定mac地址\n1 2 ip link set \u0026lt;ethname\u0026gt; vf 0 mac 00:11:22:33:44:55 ip link set \u0026lt;ethname\u0026gt; vf 1 mac 00:11:22:33:44:56 rc.local添加可执行权限\n1 chmod +x /etc/rc.local 重启\n1 reboot 查看网卡信息\n1 lspci | grep \u0026#39;Virtual Function\u0026#39; 其他 查看网卡\n1 2 lspci | grep Eth # 查看所有网卡 ethtool \u0026lt;ethname\u0026gt; # 查看某个网卡信息 重新生成内核启动项\n1 grub2-mkconfig -o /boot/grub2/grub.cfg 问题 网卡无法生成vf，intel/mellanox，write error: Cannot allocate memory “not enough MMIO resources for SR-IOV” (icode9.com)\n(53条消息) echo: write error: Cannot allocate memory_u013431916的博客-CSDN博客\n引用 CentOS7でSR-IOV設定 - Metonymical Deflection (hatenablog.com)\nConfigure SR-IOV Network Virtual Functions in Linux* KVM* (intel.com)\nChapter 9. SR-IOV support for virtual networking Red Hat Enterprise Linux OpenStack Platform 7 | Red Hat Customer Portal\nSR-IOV是什么？性能能好到什么程度？ - 知乎 (zhihu.com)\n","date":"2022-02-21T12:07:32Z","permalink":"https://coderfamer.github.io/p/centos7-sr-iov-%E8%AE%BE%E7%BD%AE/","title":"CentOS7 SR-IOV 设置"},{"content":"标题冲突了么 ","date":"2022-02-09T17:20:03+08:00","permalink":"https://coderfamer.github.io/p/%E6%88%91%E6%98%AF%E6%A0%87%E9%A2%98/","title":"我是标题"},{"content":"文件浏览器 xyplorer directory opus total comman\n","date":"2021-11-02T20:07:32Z","permalink":"https://coderfamer.github.io/p/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B8%85%E5%8D%95/","title":"常用软件清单"},{"content":"git describe 命令详解 git 获取最新的 tag 查找最近的tag\n1 2 3 git describe # 不需要后缀 git describe --abbrev=0 获取当前分支的tag\n1 git describe --abbrev=0 --tags 获取所有分支的tag\n1 git describe --tags `git rev-list --tags --max-count=1` ","date":"2021-08-29T15:07:32Z","permalink":"https://coderfamer.github.io/p/git-describe-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","title":"git describe 命令详解"},{"content":"git prune 清理无效分支 git 在远程目录上删除了一个分支，本地追踪分支并不会删除，命令 git prune 可以清理无效分支\n1 2 3 4 # 查看失效分支 git remote prune origin --dry-run # 清理失效分支 git remove prune origin ","date":"2021-08-29T15:07:32Z","permalink":"https://coderfamer.github.io/p/git-describe-%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/","title":"git describe 命令详解"},{"content":"Samba - 如何配置 samba 客户端 SMB（Server Message Block）又称 CIFS(Common Internet File System),一种应用层网络传输协议。 本文介绍 centos 7 如何访问 smb 服务器的共享目录\n安装 samba 软件 1 yum -y install samba samba-client cifs-utils 注意: 推荐安装 samba 软件\n创建挂载目录\n1 mkdir -p /mnt/projects 确认是否能够连接到服务器，以及可以访问的共享目录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # sambalicent -L //samba-server -U samba-username smbclient -L //samba-server -U samba Enter SAMBA\\samba_user1\u0026#39;s password: Domain=[LOCALHOST] OS=[Windows 6.1] Server=[Samba 4.6.2] Sharename Type Comment --------- ---- ------- homes Disk Home Directories print$ Disk Printer Drivers shared Disk Shared Directories projects Disk Shared Directories IPC$ IPC IPC Service (Samba server samba-storage) samba Disk Home Directories Domain=[LOCALHOST] OS=[Windows 6.1] Server=[Samba 4.6.2] Server Comment --------- ------- Workgroup Master --------- ------- SAMBA LOCALHOST 手动挂载测试\n1 mount -t cifs -o user=samba-username,password=pw123 //samba-server/projects /mnt/projects 挂载成功之后，使用 df -h 命令可查看目录映射 解挂命令\n1 unmount /mnt/projects 添加开机自动挂载 在 /etc/fstab 文件里面添加类似命令\n1 //samba-server/projects /mnt/projects cifs username=samba,password=pw123,soft,rw 0 0 测试\n1 mount -a 参考文档 Samba – How to set up a Samba client on CentOS/RHEL 7\n","date":"2021-08-26T16:07:32Z","permalink":"https://coderfamer.github.io/p/centos-7-%E9%85%8D%E7%BD%AE-samba-client/","title":"centos 7 配置 samba client"},{"content":"git stash 命令 储藏修改 问题 在新增业务的过程中，需要修复一个紧急bug，但是当前分支已经修改了很多内容，想要切换分支，但是不想提交当前的内容。\n解决办法 可以把当前的修改内容储藏起来，并将储藏内容推送到栈上\n用法 保存 1 git stash [save message] save为可选项，可对当前的储藏添加备注信息。\n取出 1 2 3 4 git stash pop\t# 恢复最近一次的储藏内容，恢复一次即删除 git stash pop stash@{num}\t# 恢复指定序号的储藏内容 git stash apply\t# 同上，不过可恢复多次 git stash apply stash@{num}\t# 同上 其它 1 2 3 git stash list git stash drop git stash clear ","date":"2021-05-18T03:41:23Z","permalink":"https://coderfamer.github.io/p/git-stash-%E5%91%BD%E4%BB%A4-%E5%82%A8%E8%97%8F%E4%BF%AE%E6%94%B9/","title":"git stash 命令 储藏修改"},{"content":"c strtok 字符串分割 常规写法，线程不安全 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;string.h\u0026gt; void str_split(char *str, char * delim) { char *ptr = strtok(str, delim); while (ptr != NULL) { printf(\u0026#34;%s\\n\u0026#34;, ptr); ptr = strtok(NULL, delim); } return; } 线程安全 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;string.h\u0026gt; void str_split_safe(char *str, char *delim) { char strtokbuff[256] = { 0 }; char *ptr = strtok_r(str, delim, \u0026amp;strtokbuff); while (ptr != NULL) { printf(\u0026#34;%s\\n\u0026#34;, ptr); ptr= strtok_r(NULL, delim, \u0026amp;strtokbuff); } } ","date":"2021-05-07T12:47:32Z","permalink":"https://coderfamer.github.io/p/c-strtok-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/","title":"c strtok 字符串分割"},{"content":"","date":"2021-05-06T20:07:32Z","permalink":"https://coderfamer.github.io/p/wireguard-%E9%85%8D%E7%BD%AE/","title":"wireguard 配置"},{"content":"xyplorer 访问 samba 时候拒绝访问 问题 Ubuntu 配置好 samba 之后，自带文件管理器可以访问 samba 共享目录，但是用 xyplorer 访问时候， xyplorer 提示拒绝访问\n原因 本地文件管理器在访问 samba 共享目录时候会提示输入账户名密码，而 xyplorer 不会与自带文件管理器同步密码，所以导致拒绝访问\n解决办法 只需要在 xyplorer 中做个网络映射即可\n操作步骤 Tools -\u0026gt; 特殊工具 -\u0026gt; 映射网络驱动器 任选一个盘符之后，输入 samba 创建的账户名即可\n","date":"2021-05-06T20:07:32Z","permalink":"https://coderfamer.github.io/p/xyplorer-%E8%AE%BF%E9%97%AE-samba-%E6%97%B6%E5%80%99%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/","title":"xyplorer 访问 samba 时候拒绝访问"},{"content":"centos7 安装nginx 先决条件 root权限56 selinux设置 安装步骤 step 1 更新存储库列表 1 sudo yum -y update step 2 从EPEL安装外部包 nginx不在centos标准库中，所以需要从EPEL中安装。首先安装EPEL\n1 sudo yum -y install epel-release step3 安装nginx 命令 如下\n1 sudo yum -y install nginx step4 启动nginx 1 2 3 4 # 启动nginx systemctl start nginx # 查看nginx状态 systemctl status nginx step5 设置nginx开机自启动 1 systemctl enable nginx step6 配置防火墙 centos 7 默认开启防火墙，所以端口无法访问。可以选择关闭防火墙或者配置端口可访问\n方法一 关闭防火墙 1 2 3 4 # 关闭防火墙 systemctl stop firewalld # 关闭开机自启动 systemctl disable firewalld 方法二 开放端口 1 2 3 firewall-cmd --zone=public --permanent --add-service=http firewall-cmd --zone=public --permanent --add-service=https firewall-cmd reload step 7 检查nginx是否安装成功 查看nginx所在的主机的IP地址，打开浏览器在地址栏输入 http://ip ,如果出现含有 “Welcome to CentOS”的界面，说明nginx安装成功\nnginx管理常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 停止服务 systemctl stop nginx # 重启服务 systemctl restart nginx # 重新加载服务 systemctl relaod nginx # 启用/禁用开机自启动 systemctl enable/disable nginx # 重启nginx nginx -s reload # 停止nginx nginx -s stop # 查看配置文件路径，并检测配置文件的正确性 nginx -t ","date":"2020-12-23T16:07:32Z","permalink":"https://coderfamer.github.io/p/centos7-%E5%AE%89%E8%A3%85nginx/","title":"centos7 安装nginx"},{"content":"","date":"2020-11-28T12:07:32Z","permalink":"https://coderfamer.github.io/p/c-%E7%AC%94%E8%AE%B0enum/","title":"c++笔记：enum"},{"content":"c++笔记：我所理解的const 编写程序的时候，我们希望定义个变量，它的值不能被改变，为了满足这一需求，可以用const关键词进行限定。const关键字可用于c++各种环境：\n变量 引用和指针 函数参数和返回值 类成员变量 类成员函数 const修饰变量 当const修饰于变量时，其值不能改变。即在声明变量之后，不允许进行赋值操作\n1 2 3 4 5 void const_variables() { const int a = 20; // a++; // error:对只读变量进行赋值操作 } const 修饰引用 与 const 修饰变量相似，引用本身和引用对象是一体的，所以只存在一种情况。const 引用本身不可变，const 引用对象根据对象属性决定是否可变。\n1 2 3 4 5 6 7 8 9 10 11 void const_reference() { int a = 20; const int \u0026amp; r = a; r++; // error : 引用本身不可变 const int b = 20; const int \u0026amp; rb = b; b++; // error: 引用对象不可变 rb++; // error: 引用本身不可变 } const 修饰指针 const 对于指针修饰操作，可分为三种方式：修饰指针指向、修饰指针本身或同时修饰指针指向和本身\n1 char hello[] = \u0026#34;hello\u0026#34;; 修饰指针指向 1 const char *p = hello; // 指针可变，指针指向不可变 修饰指针本身 1 char * const p = hello; // 指针不可变，指针指向可变 同时修饰指针本身和指向 1 const char * const p = hello; // 指针不可变，指针指向不可变 《Effective c++》 中介绍了记忆方法:\n如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针自身是常量；如果出现在星号两边，表示被指物和指针两者都是常量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void const_point() { char a[] = \u0026#34;hello\u0026#34;; char b[] = \u0026#34;world\u0026#34;; const char * p1 = a; p1[2] = \u0026#39;m\u0026#39;; // error: 指针本身不可变 p1 = b; // 指针指向可变 char * const p2 = a; p2[2] = \u0026#39;m\u0026#39;; // 指针本身可变 p2 = b; // error: 指针指向不可变 const char * const p3 = a; p3[2] = \u0026#39;m\u0026#39;; // error: 指针本身不可变 p3 = b; // error: 指针指向不可变 } const函数参数和返回类型 对于 const 修饰函数参数，与 const 修饰指针或者变量类似。如果函数内部对函数参数不进行修改操作，则可以对参数用const 修饰。变量、指针或者引用都可以进行操作。\n当 const 修饰类对象引用时，对于性能还有一定提升。常规类对象作为参数，要经历 构造、拷贝、析构等流程，如果用const引用，不仅直接保护该对象本身，同时也省去了构造等一些流程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // @para: _a _a值不可变 // @para: _p2 _p1指针本身不可变，_p1指向对象内容可变 // @para: _p2 _p2指针本身和内容都不可变 // @para: _data _data不可变 const char _str[] = \u0026#34;const\u0026#34;; void const_func_args(const int _a, const char * _p1, const char * const _p2, const Data \u0026amp; _data) { _a++;\t// error _p1 = _str; _p1[2] = \u0026#39;m\u0026#39;; //error _p2 = _str; // error _p2[2] = \u0026#39;m\u0026#39;; // error } 对于 const 返回值，记住其中一点即可。const函数返回值不可当左值使用，一定程度上可以防止用户误写代码导致的错误。《Effective c++》中就有一个样例，重载 * 运算符，误使用导致不必要的麻烦。\n1 2 3 4 class Rational {...}; const Rational operator *(const Rational \u0026amp;lhs, const Rational \u0026amp;rhs); Rational a, b, c; (a * b) = c;\t// 误写代码导致不必要的麻烦. const成员变量 c++ const成员变量和普通const变量用法相似。不过也存在明显的区别：\nconst 成员变量只能通过声明和初始化列表初始化 相同类不同对象的const成员变量值可能不一样。 const 成员变量初始化 由于const变量的特性，const变量在声明之后就不可改变。对于c++类来说，成员变量生命之后可在构造函数内部进行初始化，这样违背了const变量的特性。不过构造函数还支持初始化列表初始化，对于 const成员变量可在成员初始化列表中进行初始化\n1 2 3 4 5 6 7 8 9 class ConstMember { public: ConstMember(int _mem) : mem_(_mem) { // 可以在初始化列表中初始化 mem_ = 20; // error: 不能在构造函数中对const成员变量进行初始化 } private: const int mem_ = 30; // 根据c++类特性，可在类内声明时初始化 }; 相同类不同对象的const成员变量值可能不一样 当const成员变量在初始化列表中初始化时，可能调用的是有参构造函数，这样在声明类对象的时候，const成员变量值会根据类对象的参数改变\n1 2 ConstMember member1(30);\t// const成员变量值为30 ConstMember member2(40);\t// const成员变量值为40 const成员函数 const成员函数目的也是保护数据，写法是在函数声明尾部加上const\n1 2 3 4 5 6 7 8 9 10 11 12 class ConstFunc { public: void GetVal() const; private: int val_; }; void ConstFunc::GetVal() const { return this-\u0026gt;val_; } 注意：const成员函数声明和定义尾部都需要加上const\n上述demo中，显示写出了this指针。这个是c++类成员函数的特性，除static成员函数的所有成员函数都会隐式绑定this指针。默认情况下，this的类型是指向类型非常量版本的常量指针，即 ConstFunc * const。尽管this指针为隐式的，this指针也遵循初始化规则，意味着我们不能把this绑定到一个常量对象上。这种情况也导致了我们不能在常量对象上调用普通成员函数。\n不能改变成员变量的值 不能调用普通成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 class ConstFunc { public: int GetVal() const { SetVal(20);\t// error： 不能在常量对象上调用普通成员函数 data_++;\t// error: 不能在常量对象上修改成员变量 return val_; } void SetVal(int _val) { val_ = _val; } private: int val_; int data_; }; const成员函数重载 1 2 3 4 5 6 class ConstOverload { public: void GetValue();\tvoid GetValue() const;\t// 可视为函数重载 }; 其他 const 常量表达式 替代预处理宏 #define 当文件中需要定义常量的时候，常规使用 #define 宏定义，可用 const 对 #define 进行替换，原因如下:\n#define 属于预处理器的语法，在代码层面只进行简单的文本替换。不进入 symbol table 中，对于 debug 和排错有一定的难度。 const 是 c++ 编译器语法，会提供类型检查和调试信息。 1 2 3 // #define MAX_LEN 200 // 使用 const 替代 #define const int MAX_LEN = 200; 小知识 对于 const 修饰的变量，有些同学会将 const 关键字写在类型之前，有些会写在类型之后、星号之前。这两种写法的意义是一样的。\n1 2 const int * a; int const * a; 参考文档 《effective c++》:\n条款03：尽量以 const、enum、inline 替换#define(Prefer const,enums,and inlines to #defines)\n条款03：尽可能使用const(Use const whenever possbile)\n《c++ primer》第五版:\n第二章 2.4 const限定符 第六章 6.2 const形参和实参 第七章 7.1 设计Sales_data类 ","date":"2020-11-28T12:07:32Z","permalink":"https://coderfamer.github.io/p/c-%E7%AC%94%E8%AE%B0%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84const/","title":"c++笔记：我所理解的const"},{"content":"kvm 安装 webvirtmgr 前言 熬了十几个日夜，google 探索了 n 个问题，熬掉了十几根头发，最终发现解决方案就在眼前，让人可恨又可爱的 man 手册。终究还是对搜索引擎的过度依赖导致浪费了过多的时间在这个问题上面，不过也还不错，有比较巨大的收获。记录一下这次历程，深刻学习教训。 起初目的是搭建 libvirt + webvirtmgr 环境，因此需要开启 libvirt tcp 监听，操作系统选择的 ubuntu20.04，在网上搜索的基本都是低于20.04 版本的教程，也因此走了很多弯路\n环境 系统以及版本 （只列出必备） ubuntu20.04\nlibvirt-daemon-system (版本 libvirt-daemon_6.0.0-0ubuntu8_amd64)\n网上大部分教程都不能盲目使用，需要根据操作系统和版本酌情参考。本次安装为纯净 ubuntu20.04 环境安装（重装了好几次系统）。\nlibvirt 依赖安装以及配置 安装必备包 1 2 sudo apt-get install libvirt-daemon-system libvirt-clients sudo apt-get install sasl2-bin libsasl2-modules bridge-utils libvirtd 修改配置项目 修改启动项参数 默认安装之后，libvirtd 默认监听 unix 域套接字，需要开启 tcp 监听。打开 libvirtd 启动项修改配置。 sudo vim /etc/default/libvirtd\n1 libvirtd_opts=\u0026#34;-l\u0026#34; 修改配置文件 修改 /etc/libvirt/libvirtd.conf ,修改如下配置\n1 2 3 4 5 6 # 允许tcp监听 listen_tcp = 1 listen_tls = 0 # 配置tcp通过sasl认证 auth_tcp = \u0026#34;none\u0026#34; 屏蔽其他无关服务 1 2 sudo systemctl mask libvirtd.socket libvirtd-ro.socket \\ libvirtd-admin.socket libvirtd-tls.socket libvirtd-tcp.socket 重启服务即可\n服务相关命令 1 2 3 4 5 6 7 8 # 重启服务 sudo systemctl restart libvirtd # 启动服务 sudo systemctl start libvirtd # 查看服务状态 sudo systemctl status libvirtd # 停止服务 sudo systemctl stop libvirtd 测试服务是否启动成功 1 virsh -c qemu+tcp://localhost/system list 其他命令 1 2 # 取消屏蔽 sudo systemctl unmask libvirtd.socket 参考资料 man 手册\nnginx\n配置网桥 ubuntu 中，使用 netplan 配置网络，修改 01-network-manager-all.yaml\n1 sudo vim /etc/netplan/01-network-manager-all.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Let NetworkManager manage all devices on this system network: version: 2 ethernets: enp1s0: dhcp4: false dhcp6: false bridges: br0: addresses: - 192.168.0.109/24 gateway4: 192.168.0.1 nameservers: addresses: [8.8.8.8, 114.114.114.114, 192.168.0.1] interfaces: - enp1s0 上面 ip 地址，物理网卡名称和虚拟网卡名称根据实际情况更改,改完之后，执行\n1 sudo netplan apply 更新网络配置，执行\n1 sudo brcth show 查看网络是否正常，br0网卡是否活跃\n安装 WebVirtMgr 安装 python2 python-pip Ubuntu 20.04 不再包含 python2 的 pip 源。可以通过 Python2 执行 get-pip.py 脚本安装。 启用 universe 存储库\n1 sudo add-apt-repository universe 安装 python 2\n1 2 sudo apt update sudo apt install python2 用 curl 下载 get-pip.py 脚本\n1 2 3 # 操作系统中如果没有 curl, 先下载 curl sudo apt intall curl curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py 安装 pip\n1 2 3 sudo python2 get-pip.py # 查看是否安装成功 pip2 --version 输出\n1 pip 20.3.4 from /home/quan/.local/lib/python2.7/site-packages/pip (python 2.7) 安装 python-libvirt\n","date":"2020-04-13T23:07:32Z","permalink":"https://coderfamer.github.io/p/kvm-%E5%AE%89%E8%A3%85-webvirtmgr/","title":"kvm 安装 webvirtmgr"},{"content":"kvm 安装 webvirtmgr 前言 熬了十几个日夜，google 探索了 n 个问题，熬掉了十几根头发，最终发现解决方案就在眼前，让人可恨又可爱的 man 手册。终究还是对搜索引擎的过度依赖导致浪费了过多的时间在这个问题上面，不过也还不错，有比较巨大的收获。记录一下这次历程，深刻学习教训。 起初目的是搭建 libvirt + webvirtmgr 环境，因此需要开启 libvirt tcp 监听，操作系统选择的 ubuntu20.04，在网上搜索的基本都是低于20.04 版本的教程，也因此走了很多弯路\n环境 系统以及版本 （只列出必备） ubuntu20.04\nlibvirt-daemon-system (版本 libvirt-daemon_6.0.0-0ubuntu8_amd64)\n网上大部分教程都不能盲目使用，需要根据操作系统和版本酌情参考。本次安装为纯净 ubuntu20.04 环境安装（重装了好几次系统）。\nlibvirt 依赖安装以及配置 安装必备包 1 2 sudo apt-get install libvirt-daemon-system libvirt-clients sudo apt-get install sasl2-bin libsasl2-modules bridge-utils libvirtd 修改配置项目 修改启动项参数 默认安装之后，libvirtd 默认监听 unix 域套接字，需要开启 tcp 监听。打开 libvirtd 启动项修改配置。 sudo vim /etc/default/libvirtd\n1 libvirtd_opts=\u0026#34;-l\u0026#34; 修改配置文件 修改 /etc/libvirt/libvirtd.conf ,修改如下配置\n1 2 3 4 5 6 # 允许tcp监听 listen_tcp = 1 listen_tls = 0 # 配置tcp通过sasl认证 auth_tcp = \u0026#34;none\u0026#34; 屏蔽其他无关服务 1 2 sudo systemctl mask libvirtd.socket libvirtd-ro.socket \\ libvirtd-admin.socket libvirtd-tls.socket libvirtd-tcp.socket 重启服务即可\n服务相关命令 1 2 3 4 5 6 7 8 # 重启服务 sudo systemctl restart libvirtd # 启动服务 sudo systemctl start libvirtd # 查看服务状态 sudo systemctl status libvirtd # 停止服务 sudo systemctl stop libvirtd 测试服务是否启动成功 1 virsh -c qemu+tcp://localhost/system list 其他命令 1 2 # 取消屏蔽 sudo systemctl unmask libvirtd.socket 参考资料 man 手册\nnginx\n配置网桥 ubuntu 中，使用 netplan 配置网络，修改 01-network-manager-all.yaml\n1 sudo vim /etc/netplan/01-network-manager-all.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Let NetworkManager manage all devices on this system network: version: 2 ethernets: enp1s0: dhcp4: false dhcp6: false bridges: br0: addresses: - 192.168.0.109/24 gateway4: 192.168.0.1 nameservers: addresses: [8.8.8.8, 114.114.114.114, 192.168.0.1] interfaces: - enp1s0 上面 ip 地址，物理网卡名称和虚拟网卡名称根据实际情况更改,改完之后，执行\n1 sudo netplan apply 更新网络配置，执行\n1 sudo brcth show 查看网络是否正常，br0网卡是否活跃\n安装 WebVirtMgr 安装 python2 python-pip Ubuntu 20.04 不再包含 python2 的 pip 源。可以通过 Python2 执行 get-pip.py 脚本安装。 启用 universe 存储库\n1 sudo add-apt-repository universe 安装 python 2\n1 2 sudo apt update sudo apt install python2 用 curl 下载 get-pip.py 脚本\n1 2 3 # 操作系统中如果没有 curl, 先下载 curl sudo apt intall curl curl https://bootstrap.pypa.io/pip/2.7/get-pip.py --output get-pip.py 安装 pip\n1 2 3 sudo python2 get-pip.py # 查看是否安装成功 pip2 --version 输出\n1 pip 20.3.4 from /home/quan/.local/lib/python2.7/site-packages/pip (python 2.7) 安装 python-libvirt\n","date":"2020-04-13T23:07:32Z","permalink":"https://coderfamer.github.io/p/kvm-%E5%AE%89%E8%A3%85-webvirtmgr/","title":"kvm 安装 webvirtmgr"},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"1、左值、右值\n2、右值引用\n3、移动语义\n4、move forward\n","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"conda create -n demo\n1 2 pip freeze \u0026gt; requirements.txt pip download -r requirements.txt 1 pip install --no-index --find-links=\u0026#34;.\u0026#34; -r requirements ","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"CentOS 7 基于 devtoolset 安装 gcc 安装教程 1. 系统安装 repository 1 yum install cetnos-release-rh 2. 安装 development-tools 和 gcc 1 yum install devtoolset-8-gcc* 3. 使用 1 2 scl enable devtoolset-8 bash gcc --version ","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"curl -fsSL https://rpm.nodesource.com/setup_14.x | sudo bash -\nsudo yum install -y nodejs\nnvm 安装\n如何安装Node.js和npm在CentOS 7 | myfreax\n","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"SRIOV 直通\n加速 vswitch的网卡\n引用 测一下ESXI的vSwitch在万兆环境下的性能 - 电脑讨论 - Chiphell - 分享与交流用户体验\nPort mirroring from a Cisco Switch to a virtual machine on a VMWare ESXi host - DailySysAdmin | For all things IT!\n","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"1 直接头文件引用\n2 静态库引用\n3 系统安装引用 find_package\n优劣势\nfind_package编译速度最快，静态库引用和头文件都比较慢，目前不清楚原因\n安装教程\n9. CMake - Spdlog v1.x - DocsForge\n","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"\u0026ldquo;C_Cpp.intelliSenseEngineFallback\u0026rdquo;: \u0026ldquo;Disabled\u0026rdquo;\n\u0026ldquo;C_Cpp.intelliSenseCacheSize\u0026rdquo;: 0\n","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/","title":""},{"content":"shell 颜色语法 1 \u0026#34;\\033[背景色;字体色;效果m\u0026#34;内容\u0026#34;\\033[0m\u0026#34; 说明\n\\033[0m 表示消除样式，结尾都要加上 背景色 字体色 效果 可以只写一个 使用 echo 要加 -e 背景色 1 2 3 4 5 6 7 8 9 背景色取值范围: 40-49 40: 黑 41: 红 42: 绿 43: 黄 44: 蓝 45: 紫 46: 深绿 47: 灰白 字体颜色 1 2 3 4 5 6 7 8 9 10 11 字体颜色取值范围: 30-39 30: 黑 31: 红 32: 绿 33: 黄 34: 蓝 35: 紫 36: 深绿 37: 灰白 38:在缺省的前景颜色上设置下划线 39:在缺省的前景颜色上关闭下划线 效果 1 2 3 4 5 6 7 8 效果取值范围: 0-8 0:不使用效果 1:高亮(加深)显示 2:低亮(减弱)显示 4:下划线 5:闪烁 7:反显(替换背景色和字体颜色) 8:消隐 ","date":"0001-01-01T00:00:00Z","permalink":"https://coderfamer.github.io/p/shell-%E9%A2%9C%E8%89%B2%E8%AF%AD%E6%B3%95/","title":"shell 颜色语法"}]